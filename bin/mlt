#!/usr/bin/env python
"""mlt.
Usage:
  mlt (-h | --help)
  mlt --version
  mlt init [--template=<template>] <name>
  mlt build [--watch]
  mlt deploy
  mlt templates list

Options:
  --template=<template>  Template name for app
                         initialization [default: tf-single-node].
"""
import sys
import shutil
import os
import uuid
import json
import time
import os.path
import subprocess
import progressbar

from termcolor import colored
from docopt import docopt
from string import Template
from subprocess import call, check_output, Popen, PIPE, STDOUT
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler
from threading import Timer

def duration_progress(activity, duration, is_done):
  def progress(activity, iterations=100):
      bar = progressbar.ProgressBar(widgets=[activity, ' ', progressbar.Bar(), ' (', progressbar.ETA(), ') ', ])
      return bar(range(iterations))

  if duration is not None:
    iterations = 100
    time_per_iteration = float(duration) / float(iterations)

    bar = progress(activity, iterations)
    cursor = 0
    for cursor in range(iterations):
        bar.next()
        time.sleep(time_per_iteration)

        # If done early.
        if is_done():
          bar.update(100)
          break

  if not is_done():
      # if still not done.
      bar = progressbar.ProgressBar(widgets=[activity, ' ', progressbar.RotatingMarker(), ' (', progressbar.Timer(), ') ', ], max_value=progressbar.UnknownLength)
      i = 0
      while not is_done():
          bar.update(i)
          i += 1

  print("")

class EventHandler:
  def __init__(self, args):
    self.args = args
    self.last_changed = time.time()
    self.dirty = False
    self.timer = None

  def dispatch(self, event):
    if event.src_path == "./.git" or event.src_path == "./":
      return

    is_ignored = call(["git", "check-ignore", event.src_path], stdout=open(os.devnull, 'wb')) == 0
    if is_ignored:
      return

    if self.timer:
      self.timer.cancel()

    def timer_triggered():
      do_build(self.args)

    self.timer = Timer(3, timer_triggered)
    self.timer.start()


def build(args):
  if args['--watch']:
    event_handler = EventHandler(args)
    observer = Observer()
    observer.schedule(event_handler, './', recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)

    except KeyboardInterrupt:
        observer.stop()
    observer.join()

  else:
    do_build(args)

def do_build(args):
  last_build_duration = None
  last_push_duration = None
  if os.path.isfile('.status.json'):
    status = json.load(open('.status.json'))
    last_build_duration = status['last_build_duration']
    last_push_duration = status['last_push_duration']

  started_build_time = time.time()

  config = json.load(open('.studio.json'))
  app_name = config['name']
  namespace = config['namespace']

  container_id = str(uuid.uuid4())
  run_id = str(uuid.uuid4())
  container_name = app_name + ":" + container_id
  remote_container_name = "gcr.io/" + config['gceProject'] + "/" + container_name

  print("Starting build %s" % container_name)

  # Add bar
  build_process = Popen(["docker", "build", "-t", container_name, "."], stdout=PIPE, stderr=STDOUT)
  def build_is_done():
    return build_process.poll() is not None
  duration_progress('Building', last_build_duration, build_is_done)
  if build_process.poll() != 0:
    print(colored(build_process.communicate()[0], 'red'))
    sys.exit(1)

  built_time = time.time()

  started_push_time = time.time()
  run(["docker", "tag", container_name, remote_container_name])
  push_process = Popen(["gcloud", "docker", "--", "push", remote_container_name], stdout=PIPE, stderr=PIPE)
  def push_is_done():
    return push_process.poll() is not None
  duration_progress('Pushing ', last_push_duration, push_is_done)
  if push_process.poll() != 0:
    print(colored(push_process.communicate()[0], 'red'))
    sys.exit(1)

  pushed_time = time.time()

  # Write last container to file
  with open('.status.json', 'w') as f:
    f.write(json.dumps({
      "last_run": run_id,
      "last_container": remote_container_name,
      "last_build_duration": built_time - started_build_time,
      "last_push_duration": pushed_time - started_push_time
    }))
 
  print("Built and pushed to %s" % remote_container_name)


def deploy(args):
  if not os.path.isfile('.status.json'):
    do_build(args)

  config = json.load(open('.studio.json'))
  app_name = config['name']
  namespace = config['namespace']

  status = json.load(open('.status.json'))
  remote_container_name = status['last_container']
  run_id = status['last_run']

  print("Deploying %s" % remote_container_name)

  # Write new container to deployment
  for filename in os.listdir("k8s-templates"):
    with open('k8s-templates/' + filename) as f:
      deployment_template = f.read()
      s = Template(deployment_template)
      out = s.substitute(image=remote_container_name, app=app_name, run=run_id)

      with open('k8s/' + filename,'w') as f:
        f.write(out)

    ensure_namespace_exists(namespace)
    run(["kubectl", "--namespace", namespace, "apply", "-R", "-f", "k8s"])


def init(args):
  template_directory = "/".join([os.path.dirname(__file__), "..", "templates", args["--template"]])
  app_name = args["<name>"]
  try:
    shutil.copytree(template_directory, app_name)

    raw_project_bytes = check_output(["gcloud", "config", "list", "--format", "value(core.project)"])
    project = raw_project_bytes.decode("utf-8").strip()

    with open(app_name + '/.studio.json','w') as f:
      f.write('''
{
  "name": "%s",
  "namespace": "%s",
  "gceProject": "%s"
}
''' % (app_name, app_name, project))

    # Initialize new git repo in the project dir and commit initial state.
    run(["git", "init", app_name])
    run(["git", "add", "."], cwd=app_name)
    print(run(["git", "commit", "-m", "Initial commit."], cwd=app_name))

  except OSError as exc:
    if exc.errno == 17:
      print("Directory '%s' already exists: delete before trying to initialize new application" % app_name)
    else:
      print(exc)


def ensure_namespace_exists(ns):
  exit_code = call(["kubectl", "get", "namespace", ns], stdout=open(os.devnull, 'wb'))
  if exit_code is not 0:
    run(["kubectl", "create", "namespace", ns])

def run(command, cwd=None):
  try:
    output = check_output(command, cwd=cwd)
  except subprocess.CalledProcessError as e:
    print(e.output)
    sys.exit(1)

  return output

def main():
    args = docopt(__doc__, version="ML Container Templates v0.0.1")

    if args["init"]:
       init(args)

    if args["build"]:
      if not os.path.isfile('.studio.json'):
        print("`mlt build` requires you to be in a `mlt init` built directory.")
        sys.exit(1)

      build(args)

    if args["deploy"]:
      if not os.path.isfile('.studio.json'):
        print("`mlt build` requires you to be in a `mlt init` built directory.")
        sys.exit(1)

      deploy(args)

main()